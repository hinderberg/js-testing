<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="https://github.com/downloads/gnab/remark/remark-0.3.4.min.js" type="text/javascript"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
    <script src="https://github.com/downloads/kjbekkelund/remark-bekk/bekk-0.0.3.js" type="text/javascript"></script>
    <link href="https://github.com/downloads/kjbekkelund/remark-bekk/bekk-0.0.3.css" type="text/css" rel="stylesheet">
    <style type="text/css" media="screen">
      #slideshow .slide .content.front-page h1 { width: 100%; }
      .slide p { padding: 0; margin: 1.1em 0; }
      .slide ul { padding: 0; margin: 1.1em 0; }
      .slide img { max-width: 100%; max-height: 600px; }
      #slideshow .slide .content ul li { padding-left: 1.3em; }
    </style>
  </head>
  <body>
    <textarea id="source">

.front-page

# Abstraksjoner og testing i MVP-arkitektur

## Workshop 29/05/2012


Kim Joar Bekkelund og Tine Kleivane


---

.agenda

# Agenda

* Kort intro
* Jasmine
* Kode


---

# Utbytte

Se reelle eksempler på testing av JavaScript

* Både gode og dårlige måter
* Diskutere virkningene av denne typen testing

Et forslag til abstraksjoner og en JavaScript-arkitektur

* Struktur å måle både andre rammeverk og egne applikasjoner mot

---

# Utbytte

Vi skal lære å *ikke* skrive kode som dette:

    .javascript
    jQuery(function() {
      $(".user form").submit(function(e) {
        e.preventDefault();
        $.ajax({
          // ...
          success: function(data) {
            var name = data.name ? data.name : "Unknown";
            $(".user .info").append("<h1>" + name + "</h1>");
          }
        });
      });
    }

Dette er komplekst! Blant annet:

* Lytter på at siden er klar
* Lytter på submit
* Håndterer nettverkskall
* Parser respons
* Templating

---

.middle.center

Men først …

---

# Intro til Jasmine

    .javascript
    // Gruppering av specs
    describe("My tests", function(){
      // Kjører før hver test
      beforeEach(function(){
        this.color = "green";
      });

      // Kjører etter hver test
      afterEach(function(){
        this.color = "green";
      });

      // Selve testen
      it("looks green", function(){
        expect(this.color).toEqual("green");
        // Finnes mange matchere, blant annet:
        // `toBe`, `toMatch`, `toBeDefined`, `toBeTruthy`, `toContain`, osv
      });
    });

* BDD-rammeverk - vi beskriver oppførsel
* Kan kjøre standalone eller som en del av maven
* Kan kjøre asynkrone kall med `runs` og `waits`
* Brukes på flere BEKK-prosjekter

---

.pushed

![](images/monolog_cropped.png)

# Målet

Lage en superenkel Twitter-lignende applikasjon: *Monolog*

---

.middle.center

# Views

---

# Views

* Et view eier et DOM-element, som vi vil kalle `el`.
* Vi sender alltid med `el` når vi lager et view
* Det er kun views som har lov til å røre DOM-en!

---

# Views

Vi skal benytte et enkelt rammeverk: Simple.js

[http://kjbekkelund.github.com/simple/](http://kjbekkelund.github.com/simple/)

Hvordan lage et nytt view:

    .javascript
    var UserView = Simple.View.extend({

      // Vi kan legge til instansmetoder.
      // I disse metodene har vi `this` tilgjengelig.

      initialize: function(options) {
        // Kjøres automatisk når et view initialiseres
        // Tar imot et argument, en options-hash
      },

      showUserInfo: function(){
        // View-logikk og rendering
      };
    });

    // Lager en instans (og sender med `el`)
    var view = new UserView({ el: $(".user") });
    view.showUserInfo();

---

.middle.center

# Setup

All kode ligger på [https://github.com/kjbekkelund/js-tdd-kurs](https://github.com/kjbekkelund/js-tdd-kurs)

---

# Oppgave 1

Vi skal starte med å se på profilseksjonen.

Vi starter enkelt:

    .javascript
    describe("The user view", function() {
      it("should have a user when initialized", function() {
        var user = {};

        // Initialize a new view

        expect(view.user).toBeDefined();
      });
    });



---

# Gjennomgang oppgave

Test:

    .javascript
    it("should have a user when initialized", function() {
      var user = {};

      var view = new BEKK.UserView({ user: user });

      expect(view.user).toBeDefined();
    });

Kode:

    .javascript
    BEKK.UserView = BEKK.View.extend({
      initialize: function(options) {
        this.user = options.user;
      }
    });

---

# View-rendring

Et view eier et element, `el`.

`template` inneholder ren HTML som skal inn i viewet.

Det er `render` sitt ansvar er å interpolere data i template og plassere dette
i `el`.

… men å rendre `el` til DOM-en er *ikke* viewet sin oppgave!

---

# Hvordan teste view-rendering?

Er avhengig av DOM-en vi initialiserer med `el` satt til `.javascript $(".user")`

Både mye oppsett, tregt og dårlig støttet av mange test-verktøy.

Men vi kan sende inn en "tom ekvivalent", som for eksempel `.javascript $("<div></div>")`.
Vi må tilpasse til hva viewet forventer å få som input.

Eksempel:

    .javascript
    var view = new BEKK.UserView({ el: $("<div></div>" ) })

Vi har lagt til en testhjelper:

    .javascript
    expect(view).toContainInDOM("En string");

---

# Oppgave

    .javascript
    it("should show name when rendered", function(){
        var user = {
            name: "Test Testesen"
        };

        // Sjekk at navnet er rendret til DOM-en
    });


---


# Gjennomgang oppgave

Test:

    .javascript
    it("should show name when rendered", function(){
        var user = {
            name: "Test Testesen"
        };

        var view = new BEKK.UserView({ user: user, el: $("<div></div>" ) });
        view.render();

        expect(view).toContainInDOM("Test Testesen");
    });


Kode:

    .javascript
    BEKK.UserView = BEKK.View.extend({

      //...

      render: function() {
        var data = this.user;
        this.renderTemplate(data);
      }
    });

Vi extend-er fra `BEKK.View` for å samle felles view-logikk.

---

# Oppslag i DOM-en

Vi bruker `$(selector)` for ofte, og det gjør oss koblet til DOM-en.

Men nå sender vi med `el` til alle views og kan dermed slå opp lokalt i
viewets DOM med `view.DOM`-funksjonen.

    .javascript
    // går fra
    $(".user form")

    // til
    userView.DOM("form")

    // disse er ekvivalente om `.user` er `el`-en til `userView`

Løsningen med bruk av `toContainInDOM` blir for enkel siden den søker etter en
string i hele HTML-en.

---

# Oppgave

Så la oss bruke `DOM`-funksjonen istedenfor `toContainInDOM`:

    .javascript
    it("should show name in heading when rendered", function() {
        // sjekk at `h2` inneholder korrekt navn
    });

(Målet i denne oppgaven er å refaktorere den forrige testen, ikke skrive ny
funksjonalitet.)

---

# Gjennomgang

Test:

    .javascript
    it("should show name in heading when rendered", function() {
        var user = {
            name: "Test Testesen"
        };

        var view = new BEKK.UserView({ user: user, el: $("<div></div>" ) });
        view.render();

        expect(view.DOM("h2")).toHaveText("Test Testesen");
    });

Ingen implementasjon, følger med Simple.js

---

# Model

Har ansvar for data og opphenting av denne

* Kun modeller som har lov til å kommunisere med serveren

I Simple.js følger vi modellstrukturen til Backbone.js:

* `initialize`
* `url`
* `toJSON`

Og i tillegg:

* `attr("prop")` og `attr("prop", set)`

---

# Oppgave

    .javascript
    it("should render model", function() {
        // Samme test som sist, men nå skal input til viewet være en BEKK.User
    });

---

# Gjennomgang oppgave

Test:

    .javascript
    it("should render model", function() {
        var user = new BEKK.User({ screen_name: "kimjoar" });
        user.attr("name", "Kim Joar Bekkelund");

        var view = new BEKK.UserView({ user: user, el: $("<div></div>" )});
        view.render();

        expect(view.DOM("h2")).toHaveText("Kim Joar Bekkelund");
    });


Kode:

    .javascript
      BEKK.UserView = BEKK.View.extend({

        //...

        render: function() {
          var data = this.user.toJSON();
          this.renderTemplate(data);
        }
      });

---

# Model

Simple.js implementerer `model.fetch` med success-callback:

    .javascript
    user.fetch({
      success: function() {}
    });

Kaller på `model.url`

Kan sette JSONP ved å sette `model.dataType = "jsonp"`

---

# Oppgave

    .javascript
    it("should populate the view when data is fetched", function() {
        var view;

        // runs(function(){});

        // waits(1000);
        // vi venter på å motta svar fra Twitter

        // runs(function(){});
    });

---

# Gjennomgang oppgave

Test:

    .javascript
    it("should populate the view when data is fetched", function() {
        var view;

        runs(function(){
            var user = new BEKK.User({ screen_name: "kimjoar"});
            view = new BEKK.UserView({ user: user, el: $('<div></div>') });

            user.fetch({
              success: function() {
                view.render();
              }
            });
        });

        waits(1000);

        runs(function(){
            expect(view.DOM("h2")).toHaveText("Kim Joar Bekkelund");
        });
    });

Kode:

Er allerede implementert.

---

# Hva lærte vi av forrige test?

Dette går treeegt!

Og det er vanskelig å vite hvor tregt. Når vi testet feilet det 1 av 3 ganger på 500ms.

Vanskelig i store prosjekter siden vi må ha en kjørende app i byggeprosessen.

… det må finnes bedre måter å gjøre dette på!

---

# sinon.js

[http://sinonjs.org](http://sinonjs.org)

"Standalone test spies, stubs and mocks for JavaScript. No dependencies, works
with any unit testing framework."

Inneholder også:

* Fake timers for `setTimeout()`
* Fake server &amp; XHR for mocking av AJAX-kall

Det finnes ekstra matchers for Jasmine, se
[https://github.com/froots/jasmine-sinon](https://github.com/froots/jasmine-sinon).

---

# Mocking av AJAX-kall

Vi benytter `sinon.fakeserver`:

    .javascript
    // Setup
    this.server = sinon.fakeServer.create();

    // Setup av en response
    this.server.respondWith([statusCode, headers, data]);

    // Simuler at responsen mottas
    this.server.respond()

    // Teardown
    this.server.restore();

På den positive siden:

* Mye, mye raskere tester

… men:

* Registerer ikke endringer i API-et.

---

# Oppgave

    .javascript
    beforeEach(function() {
        this.response = '{"name": "Kim Joar Bekkelund","followers_count": "200","friends_count": "100"}';
        this.options = {};
    });

    it("should populate the view when data is fetched", function() {
        var user = new BEKK.User({screen_name: "kimjoar"});

        // sinon.js støtter ikke JSONP
        user.dataType = "json";

        // Sett opp en fakeServer

        // Sjekk for korrekt data i viewet
    });

---

# Gjennomgang oppgave

Test:

    .javascript
    it("should populate the view when data is fetched", function() {
        this.server = sinon.fakeServer.create();
        this.server.respondWith([200, this.options , this.response]);

        var user = new BEKK.User({screen_name: "kimjoar"});

        // sinon.js støtter ikke JSONP
        user.dataType = "json";

        var view = new BEKK.UserView({ user: user, el: $('<div></div>')  });

        user.fetch({
          success: function(){
            view.render();
          }
        });

        this.server.respond();
        this.server.restore();

        expect(view.DOM("h2")).toHaveText("Kim Joar Bekkelund");
        expect(view.DOM(".followers")).toHaveText("200");
        expect(view.DOM(".following")).toHaveText("100");
    });

---

# Callback

Hvorfor skal koden utenfra vite noe om hvordan viewet skal håndtere respons?

    .javascript
    user.fetch({
      success: function(){
        view.render();
      }
    });

Eller, dersom vi flytter hentingen inn: hvorfor skal viewet være ansvarlig for
å hente sin dataen?

Dette burde være:

    .javascript
    user.fetch();

Og så kan viewet få beskjed ved suksess.

---

# Events!

Viewet sier fra hva den er interessert i å lytte på og får beskjed når
handlingen skjer.

Dette gir bedre decoupling. Skiller ansvaret ut der det hører hjemme.

    .javascript
    var user = new BEKK.User();

    user.on("test", function() { console.log(this); }, this);

    user.trigger("test");

Når et modell kaller `fetch` og kallet ender i suksess, trigges automatisk
eventen `fetch:finished`

---

# Oppgave

    .javascript
    it("should populate the view when data is fetched", function(){
        // Refaktorering av oppgaven over til å
        // benytte seg av events på ferdig henting av data
    });

---

# Gjennomgang av oppgave

Test:

    .javascript
    it("should populate the view when data is fetched", function(){
        this.server = sinon.fakeServer.create();
        this.server.respondWith([200, this.options, this.response]);

        var user = new BEKK.User({screen_name: "kimjoar"});
        user.dataType = "json";

        var view = new BEKK.UserView({ user: user, el: $('<div></div>')  });

        user.fetch();

        this.server.respond();
        this.server.restore();

        expect(view.DOM("h2")).toHaveText("Kim Joar Bekkelund");
        expect(view.DOM(".followers")).toHaveText("200");
        expect(view.DOM(".following")).toHaveText("100");
    });

Kode:

    .javascript
    BEKK.UserView = BEKK.View.extend({
      initialize: function(options) {
        // ...
        this.user.on("fetch:finished", this.render, this);
      }
    });

---

# En testabstraksjon: fakeResponse

Det er grusomt kjedelig å skrive:

    .javascript
    this.server = sinon.fakeServer.create();
    this.server.respondWith([200, this.options, this.response]);

Løsning: `fakeResponse` (se i `helper/fakeResponse.js`)

    .javascript
    fakeResponse(response, options, function() {
        // callback som kalles i kontekst av et mocket AJAX-kall
    });

Når man etterhvert får store responser, fungerer den også bra med fixtures.

---

# Oppgave

    .javascript
    it("should populate the view when data is fetched", function(){
        // refaktorer oppgaven til å benytte seg av fakeResponse
    });

---

# Gjennomgang av oppgave

Test:

    .javascript
    it("should populate the view when data is fetched", function(){
        var user = new BEKK.User({screen_name: "kimjoar"});
        user.dataType = "json";

        var view = new BEKK.UserView({ user: user, el: $('<div></div>')  });

        fakeResponse(this.response, this.options, function() {
          user.fetch();
        });

        expect(view.DOM("h2")).toHaveText("Kim Joar Bekkelund");
        expect(view.DOM(".followers")).toHaveText("200");
        expect(view.DOM(".following")).toHaveText("100");
    });

---

# Lytte på DOM-eventer

I tillegg til å oppdatere DOM-en, er et view ansvarlig for å lytte på
DOM-eventer.

Alle DOM-eventene viewet lytter på, kan legges i `events`-property-en:

    .javascript
    var UserView = BEKK.View.extend({
        events: {
          "click h1": "editHeading"
        },

        editHeading: function() {}
    });

---

# Globale events

Når flere komponenter kan være interessert i en handling som har skjedd.

Løsere kobinger mellom komponenter.

Lettere kan legge til eller fjerne komponenter.

    .javascript
    it("adds a monolog on 'new-status' event", function() {
      Simple.events.trigger("new-status", "The status");
    });

---

# Oppgave

* `newStatusViewSpec.js`
* Få manglende test i `monologSpec.js` til å kjøre.
* Siste spec i `userViewSpec.js`
* `statusesViewSpec.js`

Implementer `BEKK.start()` slik at app-en kjører.

---

# Sammensatte views

Et view kan bestå av flere views.

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
